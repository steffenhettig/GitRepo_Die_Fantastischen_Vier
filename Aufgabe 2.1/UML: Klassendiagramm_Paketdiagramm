@startuml

top to bottom direction

package App 
{
  class StateHandler
  {
    
  }
  note top of StateHandler
    Main can't call StateHandler if there aren't
    any functions to call.

    Think about the Single Responsibility Principle (SRP) and 
    data encapsulation for your stateHandler to have all related
    logic collected in one module.

    What should be the exact purpose of your StateHandler?
    What functions do you need to inform the StateHandler about whats happening?
    What functions are really needed to be provided to other modules?
  end note
  class Main
  {
      
  }
  package States
  {
    class SystemStart_Handler
    {
        +startTimer(): void
        +stopTimer(): void
    }
    class Wait_Handler
    {
    
    }
    note top of Wait_Handler
      Shouldn't Wait use all the buttons and then
      communicate the correcte state Change to StateHandler?
      How does ModeSwitch use the button or the other way around,
      how is the ModeSwitch used by the button?

      Do you intend using interrupts with callbacks?
      No according classes and functions are defined here.

      How about polling the button states in Wait and going
      from there?
    end note
    class Calibration_Handler
    {
    
    }
    class ModeSwitch_Handler
    {
    
    }
    note top of ModeSwitch_Handler
      Just to give you an example. ModeSwitch
      could need a function:
      ModeSwitch_SwitchToNextParameterSet(void) : void
    end note
    class StartRace_Handler
    {
        +startTimer(): void
        +stopTimer(): void
    }
    note top of StartRace_Handler
      Start Race would need to implement a algorithm to follow the line.
      Same applies for RunRace.

      So the same functionality would need to exist (and maintained) in
      two different states. Maybe a additional module in charge of
      driving would be needed or some state handlers could be merged and
      simplified.

      Remember DRY (Don't repeat yourself) and SRP (Single responsability principle).
    end note
    class RunRace_Handler
    {
        +startTimer(): void
        +stopTimer(): void
    }
    class RaceDone_Handler
    {
        +startTimer(): void
        +stopTimer(): void
    }
    class Error_Handler
    {
      
    }
  }
}

package Service
{
    class PushButton
    {
      +get_ButtonState(enum button): Int8
    }

    class LED
    {
        +setState(Int8 state): void
    }
    note top of LED
      Which LED?
    end note

    class Buzzer
    {
      +init_Buzzer(void): Int8
      +set_AlarmTone(void): void
      +set_StandardTone(void): void
    }
    
    class Display
    {
      +init_Display(void): void
      +output_Display(char* TeamName, char* MeasuredTime): void
      +reset_Display(void): void
    }
    
    class LineSensor
    {
      IsVerticalLineDetected(void): BOOL
      IsStartStopLineDetected(void): BOOL
    }

    class Motor
    {
      +set_TurningDirection(enum motor, enum direction): Int8
      +get_TurningDirection(void): enum direction
      +set_MotorSpeed(enum motor, enum direction): Int8
      +get_MotorSpeed(void): enum direction
    }
    
  note top of LED
        Provides methods to enable/disable
        the LED, via I/O.
    end note
    
  note top of PushButton
        Provides the button state,
        derived from I/O.
  end note
  

  class Clock
  {
    +get_Time(void): Int8
    +set_Time(Int8 minutes, Int8 seconds, Int8 milliseconds): Int8
    +reset_Time(void): Int8
    +start_Measurement(void): void
    +stop_Measurement(void): void
  }

}

package HAL
{
  class GPIO
  {
    +GPIO_Init(Int8 port, Int8 pin): void
    +GPIO_Write(Int8 port, Int8 pin, Int8 state): void
    +GPIO_Read(Int8 port, Int8 pin): void
  }
  class SPI
  {
    +SPI_Init(void): void
    +SPI_Transmit(): void
    +SPI_Receive(): void
  }
  class AVRTimer0
  {
    +init(void): void
    millis(void): void
  }
  note bottom of AVRTimer0
    is used for timing-related functions
  end note
  class AVRTimer4
  {
    +init(void): void
    +set_SoundFrequency(Int8 frequency): void
  }
  note bottom of AVRTimer4
    is used for controlling the buzzer
  end note
  
  class PWM_Timer1
  {
    +init(void): void
    +set_PWMFreq(Int8 frequency): void
  }
}
StateHandler --> SystemStart
StateHandler --> Wait
StateHandler --> Calibration
StateHandler --> ModeSwitch
StateHandler --> StartRace
StateHandler --> RunRace
StateHandler --> RaceDone
StateHandler --> Error

SystemStart --> Clock
SystemStart --> Display
Calibration --> LineSensor 
Calibration --> PushButton
ModeSwitch --> PushButton
StartRace --> Clock
StartRace --> Buzzer
StartRace --> MotorLeft
StartRace --> MotorRight
StartRace --> PushButton 
RunRace --> Clock
RunRace --> MotorLeft
RunRace --> MotorRight
RaceDone --> Clock
RaceDone --> Buzzer
RaceDone --> MotorLeft
RaceDone --> MotorRight
RaceDone --> Display
Error --> Buzzer
Error --> Clock

Main --> StateHandler
PushButton --> GPIO
PushButton --> GPIO
PushButton --> GPIO
LED --> GPIO
PushButton --|> PushButton
PushButton --|> PushButton
PushButton --|> PushButton
Display --> SPI
Buzzer --> AVRTimer4
Motor --|> Motor
Motor --|> Motor
Motor --> GPIO
Motor --> GPIO
Motor --> PWM_Timer1
Motor --> PWM_Timer1
LineSensor --> GPIO
Clock --> AVRTimer0
Display --> GPIO



@enduml
